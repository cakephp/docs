Аутентификация
##############

.. php:class:: AuthComponent(ComponentCollection $collection, array $config = [])

Идентификация, аутентификация и авторизация пользователей является обычной частью
почти каждого веб-приложения. В CakePHP AuthComponent предоставляет
подключаемый способ выполнения этих задач. AuthComponent позволяет комбинировать
объекты аутентификации и объекты авторизации для создания гибких
способов идентификации и проверки авторизации пользователя.

.. _authentication-objects:

Рекомендуется к прочтению
=========================

Настройка аутентификации требует нескольких шагов, включая определение
таблицы пользователей, создание модели, контроллера, видов и т. д.

Это все описывается по шагам в
:doc:`Руководстве по созданию CMS </tutorials-and-examples/cms/authentication>`.

Если вы ищете готовые решения по аутентификации и/или авторизации для
CakePHP, взгляните на раздел 
`Аутентификация и Авторизация <https://github.com/FriendsOfCake/awesome-cakephp/blob/master/README.md#authentication-and-authorization>`_ списка Awesome CakePHP.


Аутентификация
==============

Аутентификация - это процесс идентификации пользователей посредством
учетных данных и обеспечение того, чтобы пользователи были теми, за кого они
себя выдают. Как правило, это делается с помощью имени пользователя и пароля,
которые проверяются по списку известных  пользователей. В CakePHP есть
несколько встроенных способов аутентификации пользователей, имеющихся у вашего 
приложения.

* ``FormAuthenticate`` позволяет аутентификацию пользователей на основании 
  POST-данных, отправляемых с помощью форм. Как правило, это форма входа с
  с возможностью ввода учетных данных пользователем.
* ``BasicAuthenticate`` предоставляет возможности Базовой HTTP-аутентификации.
* ``DigestAuthenticate`` предоставляет возможности Дайджест-аутентификации.

По умолчанию ``AuthComponent`` использует ``FormAuthenticate``.

Выбор типа аутентификации
-------------------------

Как правило, вы захотите предложить аутентификацию на основе форм. Это самый
простой способ для пользователей веб-браузеров. Если вы создаете API или веб-сервис,
вы можете рассмотреть базовую аутентификацию или дайджест-аутентификацию. Основные
различия между дайджест- и базовой аутентификацией в основном связаны с тем, как
обрабатываются пароли. При базовой аутентификации имя пользователя и пароль
передаются в виде обычного текста на сервер. Это делает базовую аутентификацию 
непригодной для приложений без SSL, так как вы будете подвергать пароли уязвимости.
Дайджест-аутентификация передает в  хэшированном виде имя пользователя, пароль и
некоторые другие детали. Это делает дайджест-аутентификацию  более подходящей для
приложений без SSL-шифрования.

Вы также можете использовать такие системы аутентификации, как например OpenID,
но они уже не входят в состав ядра CakePHP.

Настройка обработчиков аутентификации
-------------------------------------

Вы настраиваете обработчики аутентификации, используя конфигурацию
``authenticate``. Вы можете настроить один или несколько обработчиков
для аутентификации. Использование нескольких обработчиков позволяет
вам поддерживать разные способы входа пользователей. Когда пользователи
авторизуются, обработчики аутентификации проверяются в том порядке,
в котором они были объявлены. Как только какой-либо обработчик сможет
идентифицировать пользователя, все оставшиеся обработчики уже не будут
использованы. И наоборот, вы можете прервать проверку подлинности,
выбросив исключение. Вам будет нужно перехватывать любые выбрасываемые
исключения и обрабатывать их должным образом.

Вы можете настроить обработчики аутентификации в методе 
``beforeFilter()`` либо ``initialize()``. Вы можете передавать
информацию о конфигурации в каждый объект аутентификации, используя
массив::

    // Простая настройка
    $this->Auth->config('authenticate', ['Form']);

    // Передача параметров
    $this->Auth->config('authenticate', [
        'Basic' => ['userModel' => 'Members'],
        'Form' => ['userModel' => 'Members']
    ]);

Во втором примере вы возможно обратили внимание, что ключ ``userModel``
был объявлен дважды. Чтобы ваш код соответствовал принципам DRY (не
повторяйся), вы можете использовать ключ ``all``. Этот специальный ключ
позволяет вам устанавливать параметры, которые вы передаете к каждому
прикрепленному объекту. Ключ ``all`` также доступен в качестве
статического свойства ``AuthComponent::ALL``::

    // Передача параметров с помощию 'all'
    $this->Auth->config('authenticate', [
        AuthComponent::ALL => ['userModel' => 'Members'],
        'Basic',
        'Form'
    ]);

В приведенном выше примере и ``Form`` и ``Basic`` будут получать настройки,
объявленные в ключе 'all'. Любые настройки, переданные конкретному объекту
аутентификации будут переопределять соответствующие ключи внутри ключа 'all'.
Объекты аутентификации ядра поддерживают следующие ключи конфигурации.

- ``fields`` Поля, используемые для аутентификации пользователя. Вы можете
  использовать ключи ``username`` и ``password``, чтобы указать поля для
  имени пользователя и пароля соответственно.
- ``userModel`` Имя модели для таблицы пользователей; По умолчанию - Users.
- ``finder`` Метод-файндер для получения записи из таблицы пользователей.
  По умолчанию устновлен в 'all'.
- ``passwordHasher`` Класс хешера паролей; По умолчанию ``Default``.
- Опции ``scope`` и ``contain`` являются устаревшими в версии 3.1. Используйте
  вместо них пользовательские файндеры для изменения запроса на выборку записи
  пользователя.
- Опция ``userFields`` является устаревшей в версии 3.1. Используйте метод 
  ``select()`` в вашем пользовательском файндере.
  
Чтобы настроить дополнительные поля для записи пользвателя в методе
``initialize()``::

    public function initialize()
    {
        parent::initialize();
        $this->loadComponent('Auth', [
            'authenticate' => [
                'Form' => [
                    'fields' => ['username' => 'email', 'password' => 'passwd']
                ]
            ]
        ]);
    }

Не помещайте другие ключи конфигурации ``Auth``, такие как ``authError``, ``loginAction``,
и т.д. внутрь элементов ``authenticate`` или ``Form``. Они должны находиться на одном
с ними уровне. Приведенная выше настройка конфигурации компонента ``Auth`` с использованием
остальных параметров должна выглядеть так::

    public function initialize()
    {
        parent::initialize();
        $this->loadComponent('Auth', [
            'loginAction' => [
                'controller' => 'Users',
                'action' => 'login',
                'plugin' => 'Users'
            ],
            'authError' => 'Вы правда думали, что вам можно видеть это?',
            'authenticate' => [
                'Form' => [
                    'fields' => ['username' => 'email']
                ]
            ],
            'storage' => 'Session'
        ]);
    }
    
В дополнение к стандартной конфигурации, Базовая аутентификация (Basic)
также поддерживает следующие ключи:

- ``realm`` Область, для которой предназначена аутентификация.
  По умолчанию ``env('SERVER_NAME')``.

В дополнение к стандартной конфигурации, Дайджест-аутентификация
также поддерживает следующие ключи:

- ``realm`` Область, для которой предназначена аутентификация.
  По умолчанию servername (имя сервера).
- ``nonce`` Значение nonce для аутентификации. По умолчанию ``uniqid()``.
- ``qop`` По умолчанию auth; другие значения пока не поддерживаются.
- ``opaque`` Строка, которая должна быть возвращена в неизменном виде
  клиентами. По умолчанию ``md5($config['realm'])``.

.. note::
    Чтобы найти запись пользователя, запрос к базе  данных происходит только
    с использованием имени пользователя. Проверка пароля производится в PHP.
    Это связано с тем, что алгоритмы хеширования, такие как bcrypt (алгоритм
    по умолчанию) генерируют новый хеш каждый раз, даже для неизменной строки,
    и в данном случае обычное сравнение строк в SQL становится неприменимым
    для проверки пароля.
    
Кастомизация поискового запроса
-------------------------------

Вы можете кастомизировать запрос на выборку записи пользователя с помощью
опции ``finder`` в группе параметров ``authenticate``::

    public function initialize()
    {
        parent::initialize();
        $this->loadComponent('Auth', [
            'authenticate' => [
                'Form' => [
                    'finder' => 'auth'
                ]
            ],
        ]);
    }

Это потребует наличия поискового метода ``findAuth()`` в вашем классе модели
``UsersTable``. В приведенном ниже примере запрос скорректирован для выборки
значений только из необходимых полей и добавлено условие выборки значений.
Вы должны убедиться, что происходит выборка значений из необходимых полей,
таких как ``username`` и ``password``::

    public function findAuth(\Cake\ORM\Query $query, array $options)
    {
        $query
            ->select(['id', 'username', 'password'])
            ->where(['Users.active' => 1]);

        return $query;
    }

.. note::
    Опция ``finder`` доступна только с версии 3.1. В более ранних версиях вы
    можете использовать опции ``scope`` и ``contain`` для изменения запроса.
    
Identifying Users and Logging Them In
-------------------------------------

.. php:method:: identify()

Вам необходимо вручную вызывать ``$this->Auth->identify()``, чтобы
идентифицировать пользователя, используя учетные данные предоставленные
в запросе. После этого вы должны использовать метод ``$this->Auth->setUser()``,
чтобы пользователь вошел в приложение, то есть данные о нем сохранились в
сессии.

При аутентификации пользователей прикрепленные объекты аутентификации
проверяются в том порядке, в котором они прикреплены. Как только один из
объектов сможет идентифицировать пользователя, другие объекты уже не проверяются.
Пример функции для работы с формой входа может выглядеть так::

    public function login()
    {
        if ($this->request->is('post')) {
            $user = $this->Auth->identify();
            if ($user) {
                $this->Auth->setUser($user);
                return $this->redirect($this->Auth->redirectUrl());
            } else {
                $this->Flash->error(__('Username or password is incorrect'));
            }
        }
    }

Приведенный выше код сначала попробует идентифицировать пользователя, используя
POST-данные. В случае успеха данные о пользователе будут сохранены в сессии, благодаря
чему будут доступны между отправкой запросов, и после этого будет осуществляться
перенаправление на последнюю посещенную страницу, либо на URL, указанный в параметре
конфигурации ``loginRedirect``. В случае, если попытка входа окажется неудачной -
выведется флеш-сообщение об ошибке.

.. warning::

    Метод ``$this->Auth->setUser($data)`` авторизует пользователя, независимо от того,
    какие данные были ему переданы. Он не будет проверять пользовательские данные на
    соответствие классу аутентификации.
    
Перенаправление пользователей после входа
-----------------------------------------

.. php:method:: redirectUrl

После входа пользователя в систему вы, как правило, захотите перенаправить их
обратно туда, откуда они пришли. Передайте URL-адрес для установки целевой
страницы, на которую пользователь должен быть перенаправлен после входа в
систему.

Если параметр не будет передан, возвращаемый URL будет подчиняться следующим
правилам:

- Возвращается нормализованный URL из значения ``redirect`` строки запроса если
  он существует и находится в тод же домене, что и текущее приложение. До версии
  3.4.0  использовалось значение сессионной переменной ``Auth.redirect``.
- Если в строке запроса/сессии нужное значение отсутствует, но присвоено
  какое-либо значение параметру конфигурации ``loginRedirect``, то будет
  возвращено это значение.
- Если же и в параметре ``loginRedirect`` не окажется нужного значения, будет
  возвращен ``/``.
  
Создание системы аутентификации без сохранения состояния
--------------------------------------------------------

Базовая и Дайджест-аутентификация - это системы аутентификации не сохраняющие
состояние, и не требующие исходных POST-данных или формы. Если вы используете
только эти два способа аутентификации, вашему котроллеру необязательно наличие
экшена входа в систему (login). Cистема аутентификации без сохранения состояния
перепроверяет данные пользователя при каждом запросе. это создает небольшое
количество дополнительных накладных расходов, но позволяет клиентам
осуществлять вход без использования куки и делает AuthComponent более гибким
при создании API.

Для аутентификаторов без сохранения состояния параметр конфигурации ``storage``
следует установить в ``Memory``, чтобы ``AuthComponent`` не использовал сеccию
для хранения  записи пользователя. Вы также можете настроить параметр конфигурации
``unauthorizedRedirect`` в ``false``, чтобы ``AuthComponent`` выбрасывал
``ForbiddenException`` вместо поведения по умолчанию перенаправления на ссылающуюся
страницу.

Объекты аутентификации могут реализовывать метод ``getUser()``, который может
использоваться для поддержки систем входа пользователя, независящих от файлов
cookie. Типичный метод ``getUser()`` рассматривает запрос/среду и использует эту
информацию для подтверждения личности пользователя. Например, Базовая HTTP-аутентификация
использует ``$_SERVER['PHP_AUTH_USER']`` и ``$_SERVER['PHP_AUTH_PW']`` для полей
имени пользователя и пароля.

.. note::

    Если аутентификация не работает как ожидается, проверьте, выполняются ли
    вообще запросы (смотрите ``BaseAuthenticate::_query($username)``).
    Если запросы не выполняются, проверьте заполняются ли веб-сервером
    ключи ``$_SERVER['PHP_AUTH_USER']`` и ``$_SERVER['PHP_AUTH_PW']``.
    Если вы используете Apache с FastCGI-PHP, вам возможно потребуется
    добавить следующую строку в ваш корневой файл **.htaccess**::

        RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization},L]

При каждом запросе данные значения, ``PHP_AUTH_USER`` и ``PHP_AUTH_PW``, используются
повторной идентификации пользователя, чтобы убедиться в их подлинности. Как и в
случае с методом объекта аутентификации ``authenticate()``, метод ``getUser()``
должен возвращать массив с информацией о пользователе, либо ``false`` в случае
неудачи.::

    public function getUser(ServerRequest $request)
    {
        $username = env('PHP_AUTH_USER');
        $pass = env('PHP_AUTH_PW');

        if (empty($username) || empty($pass)) {
            return false;
        }
        return $this->_findUser($username, $pass);
    }

Пример выше показывает, как вы можете реализовать метод ``getUser()``
для Базовой HTTP-аутентификации. Метод ``_findUser()`` является частью
``BaseAuthenticate``, и идентифицирует пользователя на основе имени
пользователя и пароля.

.. _basic-authentication:

Использование базовой аутентификации
------------------------------------

Базовая аутентификация позволяет создать аутентификацию без сохранения состояния,
которая может использоваться в приложениях интрасети или для простых сценариев API.
Данные пользователя при базовой аутентификации будут перепроверяться при каждом
запросе.

.. warning::
    Базовая аутентификация передает пользовательские данные в виде открытого
    текста. Вы должны использовать протокол HTTPS при использовании Базовой
    аутентификации.

Чтобы использовать базовую аутентификацию, вам понадобится настроить
``AuthComponent``::

    $this->loadComponent('Auth', [
        'authenticate' => [
            'Basic' => [
                'fields' => ['username' => 'username', 'password' => 'api_key'],
                'userModel' => 'Users'
            ],
        ],
        'storage' => 'Memory',
        'unauthorizedRedirect' => false
    ]);

Здесь мы используем имя пользователя + ключ API в качестве наших полей, а
также используем модель Users.

Создание ключей API для Базовой аутентификации
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Так как базовый протокол HTTP передает пользовательские данные в виде открытого
текста, было бы неразумно, если бы пользователи передавали свои пароли. Вместо
этого обычно используется непрозрачный ключ API. Вы можете сгенерировать эти
API-токены произвольно, используя библиотеки входящие в состав CakePHP::

    namespace App\Model\Table;

    use Cake\Auth\DefaultPasswordHasher;
    use Cake\Utility\Text;
    use Cake\Event\Event;
    use Cake\ORM\Table;

    class UsersTable extends Table
    {
        public function beforeSave(Event $event)
        {
            $entity = $event->getData('entity');

            if ($entity->isNew()) {
                $hasher = new DefaultPasswordHasher();

                // Генерируем 'токен' API
                $entity->api_key_plain = sha1(Text::uuid());

                // Хешируем токен с помощью Bcrypt, чтобы BasicAuthenticate
                // мог его проверить при входе.
                $entity->api_key = $hasher->hash($entity->api_key_plain);
            }
            return true;
        }
    }

Приведенный выше код генерирует случайный хеш для каждого пользователя по мере
их сохранения. В приведенном выше коде предполагается, что у вас есть два поля
``api_key`` - для хранения хэшированного API-ключа и ``api_key_plain`` - для
открытой текстовой версии ключа API, чтобы мы могли позже отобразить его
пользователю. Использование ключа вместо пароля означает, что даже через
простой протокол HTTP пользователи могут использовать непрозрачный токен вместо
исходного пароля. Также разумно включить логику, позволяющую восстанавливать
ключи API по запросу пользователя.

Использование Дайджест-аутентификации
-------------------------------------

Дайджест-аутентификация предлагает улучшенную модель безопасности по сравнению с
базовой аутентификацией, так как пользовательские данные никогда не передаются
в заголовке запроса. Вместо этого перается хеш.

Чтобы использовать дайджест-аутентификацию, вам понадобится настроить
``AuthComponent``::

    $this->loadComponent('Auth', [
        'authenticate' => [
            'Digest' => [
                'fields' => ['username' => 'username', 'password' => 'digest_hash'],
                'userModel' => 'Users'
            ],
        ],
        'storage' => 'Memory',
        'unauthorizedRedirect' => false
    ]);

Здесь мы используем имя пользователя + digest_hash в качестве наших полей и используем
модель Users.

Хеширование паролей для дайджест-аутентификации
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Поскольку для Дайджест-аутентификации требуется пароль, хэшированный
в формате, определенном RFC, для правильного хэширования пароля
для использования с Дайджест-аутентификацией вам следует использовать
специальную функцию хэширования пароля из ``DigestAuthenticate``. Если
вы собираетесь комбинировать дайджест-аутентификацию с любыми другими
стратегиями аутентификации, рекомендуется также сохранить
дайджест-пароль в отдельном поле,отличном от обычного хеша пароля::

    namespace App\Model\Table;

    use Cake\Auth\DigestAuthenticate;
    use Cake\Event\Event;
    use Cake\ORM\Table;

    class UsersTable extends Table
    {
        public function beforeSave(Event $event)
        {
            $entity = $event->getData('entity');

            // Создание пароля для дайджест-аутентификации.
            $entity->digest_hash = DigestAuthenticate::password(
                $entity->username,
                $entity->plain_password,
                env('SERVER_NAME')
            );
            return true;
        }
    }

Пароли для дайджест-аутентификации нуждаются в несколько большем количестве
информации, чем другие хеши паролей для дайджест-аутентификации, основанные
на RFC.

.. note::

    Третий параметр метода DigestAuthenticate::password() должен совпадать
    со значением параметра конфигурации 'realm', объявленным, когда
    DigestAuthentication настраивалось в AuthComponent::$authenticate.
    По умолчанию его значение - это ``env('SCRIPT_NAME')``. Возможно вам
    захочется изменить это значение на какую-нибудь статичную строку, если
    вы например хотите иметь согласованные хеши в различных окружениях.


.. meta::
    :title lang=ru: Аутентификация
    :keywords lang=ru: обработчики аутентификации,массив php,базовая аутентификация,веб-приложение,различные способы,учетные данные,исключения,cakephp,logging
