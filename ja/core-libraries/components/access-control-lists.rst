アクセス制御リスト
##################

.. php:class:: AclComponent(ComponentCollection $collection, array $settings = array())

ACL はどうやって動いているのでしょうか？
========================================

多機能なシステムにはアクセス制御が必要です。アクセス制御リストは
アプリケーションの権限をきめ細かに管理するための手法ですが、その反面、
保守や管理もしやすくなっています。

アクセス制御、もしくは ACL は、なにかを要求する側と要求される側、
この２つを主に処理します。ACL 用語では、何かを使いたいと要求する側
（ほとんどの場合はユーザ）は Access Request Object(ARO) として表現
されます。一方、システムにおいて利用を要求される側（ほとんどの場合は
アクションまたはデータ）は Access Control Object(ACO) で表現されます。
これらのエンティティ（実体）は 'オブジェクト' と呼ばれます。なぜなら
要求するオブジェクトは人間ではないこともあるからです。たとえば CakePHP 
にある特定のコントローラーの能力を一部制限した状態で、アプリケーション
の他の部品にあるロジックを起動したい場合もあるのではないでしょうか。
コントローラーのアクションから Web サービスやあなたのおばあさんの
オンライン日記まで、ACO はコントロールしたい何にでもなれる可能性が
あります。

ここまでのまとめ:

-  ACO - Access Control Object - 要求される何かを表す
-  ARO - Access Request Object - 他の何かを要求する何かを表す

基本的に、ある ARO がある ACO にアクセスできるかどうかを
決めるために ACL は使われます。

すべてがどう連携して動いているのかを理解するための助けとなるように、
少しだけ実践的な例を使いましょう。ここで、ファンタジー小説である
*ロード・オブ・ザ・リング* に出て来る、お互いに仲良しの冒険チーム
が使っている、コンピュータシステムについて考えてみましょう。その
チームリーダー Gandalf は、チームの他のメンバーに関する結構な
量のプライバシーやセキュリティを維持しつつ、そのチームの資産を管理
したいと思っています。彼がまず最初にしなければならないのは、
関係する ARO （リクエスター）のリストを作ることです:

-  Gandalf
-  Aragorn
-  Bilbo
-  Frodo
-  Gollum
-  Legolas
-  Gimli
-  Pippin
-  Merry

.. note::

    ACL は認証では *ない* ことを認識してください。ACL はユーザが認証を
    通った *後で* 行われるものです。この２つは組合せて使われることも
    多いのですが、その人が誰なのか（認証）と何ができるのか(ACL)の違いを
    理解することは重要です。

Gandalf にとって次にやることは、システムが取り扱う ACO（リソース）
の初期リストを作ることです。彼のリストは以下のようになるでしょう:

-  武器
-  ひとつの指輪
-  塩漬け豚
-  外交交渉権
-  ビール

オブジェクトに関連するユーザとパーミッションの基本的な組合せを
示すマトリック的なものを使って、伝統的にいろいろなシステムが
管理されてきました。もしこの情報がテーブルの中に格納されていれば、
それは以下のようになるでしょう:

======== ======== ========= ============ ========== =======
x        武器     指輪      塩漬け豚     外交交渉権 ビール
======== ======== ========= ============ ========== =======
Gandalf                     Allow        Allow      Allow
-------- -------- --------- ------------ ---------- -------
Aragorn  Allow              Allow        Allow      Allow
-------- -------- --------- ------------ ---------- -------
Bilbo                                               Allow
-------- -------- --------- ------------ ---------- -------
Frodo             Allow                             Allow
-------- -------- --------- ------------ ---------- -------
Gollum                      Allow
-------- -------- --------- ------------ ---------- -------
Legolas  Allow              Allow        Allow      Allow
-------- -------- --------- ------------ ---------- -------
Gimli    Allow              Allow
-------- -------- --------- ------------ ---------- -------
Pippin                                   Allow      Allow
-------- -------- --------- ------------ ---------- -------
Merry                                    Allow      Allow
======== ======== ========= ============ ========== =======

ちょっと見た限りでは、これでこのシステムは問題なく動くように
見えますよね。セキュリティを維持しながら任務の割り当てが行われ
（指輪にアクセスできるのは Frodo だけ）、かつ事故を未然に防ぐ
ようになっています（ホビット族を塩漬け豚や武器に近づけない）。
これで十分細かく分けられ、かつ読みやすい、ですよね？

このように小規模なシステムなら、マトリックスによる設定でも
うまくいくでしょう。しかし成長真っ只中のシステムや、大量の
リソース(ACO)とユーザ(ARO)を持つシステムだと、テーブルが
すぐに破綻してしまうでしょう。戦場の野営地が何百箇所もあって、
それらを個別に管理することを考えてみてください。マトリックス
方式のもう一つの欠点としては、ユーザを束ねる論理的なグループ
を作ったり、それらの論理グループをベースとした（階層的な）
ユーザグループに対して、パーミッションの変更を再帰的に適用
したりということができない点です。たとえばいったん戦いが
終わったら、ホビットがビールと豚肉に自動的にアクセスできる
ようにするとかできたら便利ですよね。こういうことをユーザ単位で
やっていたら退屈だしエラーも起こりやすくなります。'ホビット族'
のすべてのメンバーに対して、一発でパーミッション変更の再帰的な
適用ができたら非常に楽です。

ACL はほとんどの場合、ARO ツリーと ACO ツリーを伴うツリー構造
として実装されます。あなたのオブジェクトをツリーとして構成する
ことにより、全体像の上で適切な状況把握を続けながら、細かい粒度で
パーミッションを配布できます。Gandalf が賢いリーダであれば、
彼の新しいシステムでは ACL を使うことを選択し、以下のように
彼のオブジェクトを構成することでしょう:

-  指輪の仲間

   -  戦士たち

      -  Aragorn
      -  Legolas
      -  Gimli

   -  魔法使い

      -  Gandalf

   -  ホビット族

      -  Frodo
      -  Bilbo
      -  Merry
      -  Pippin

   -  来訪者

      -  Gollum

ARO についてツリー構造を使うことで、Gandalf はユーザのグループ全体
に対して適用するパーミッションを、一度に定義できるようになります。
そしてこの ARO ツリーを使って、Gandalf はグループベースの
パーミッションを追加できます。

-  指輪の仲間
   (**Deny**: all)

   -  戦士たち
      (**Allow**: 武器, ビール, エルフ用食料, 塩漬け豚)

      -  Aragorn
      -  Legolas
      -  Gimli

   -  魔法使い
      (**Allow**: 塩漬け豚, 外交交渉権, ビール)

      -  Gandalf

   -  ホビット族
      (**Allow**: ビール)

      -  Frodo
      -  Bilbo
      -  Merry
      -  Pippin

   -  来訪者
      (**Allow**: 塩漬け豚)

      -  Gollum

ACL を使って Pippin が ビール へのアクセスを許可されているか
どうかを調べたい場合は、まずツリーに問合せて、それを通して
彼のパスを取り出します。この場合 指輪の仲間->ホビット族->Pippin と
なります。その後、それらの個々の箇所に異なったパーミッションが
あるので、その中で Pippin と ビール に関連する最下層の（最もはっきり
限定された）パーミッションを使います。

======================= ================ =======================
ARO ノード              パーミッション   結果
======================= ================ =======================
指輪の仲間              Deny all         ビール へのアクセスは禁止
----------------------- ---------------- -----------------------
ホビット族              Allow 'ビール'   ビール へのアクセスは許可!
----------------------- ---------------- -----------------------
Pippin                  --               まだ ビール は許可!
======================= ================ =======================

.. note::

    ACL ツリー上の 'Pippin' ノードは acl ACO へのアクセスを
    個別に禁止してはいないので、最終結果としてはその ACO への
    アクセスは許可となります。

このツリーはまた、さらに粒度の細かい制御についてもよりきめ細かく
調整できるようになっている一方、ARO グループへの一括変更も
引き続き可能となっています:

-  指輪の仲間
   (**Deny**: all)

   -  戦士たち
      (**Allow**: 武器, ビール, エルフ用食料, 塩漬け豚)

      -  Aragorn
         (Allow: 外交交渉権)
      -  Legolas
      -  Gimli

   -  魔法使い
      (**Allow**: 塩漬け豚, 外交交渉権, ビール)

      -  Gandalf

   -  ホビット族
      (**Allow**: ビール)

      -  Frodo
         (Allow: 指輪)
      -  Bilbo
      -  Merry
         (Deny: ビール)
      -  Pippin
         (Allow: 外交交渉権)

   -  来訪者
      (**Allow**: 塩漬け豚)

      -  Gollum

このアプローチにより、広範囲なパーミッションの変更と細かい粒度の
調整が可能になっています。これですべてのホビットは ビール に
アクセスできますが、唯一の例外は Merry です。Merry が ビール
にアクセスできるかどうかを調べるには、ツリー上で彼のパスを
検索します: 指輪の仲間->ホビット族->Merry 。そして上から順番に
リストに当たり、ビール に関係するパーミッションを追跡します:

======================= ================ =======================
ARO ノード              パーミッション   結果
======================= ================ =======================
指輪の仲間              Deny all         ビール へのアクセスは禁止
----------------------- ---------------- -----------------------
ホビット族              Allow 'ビール'   ビール へのアクセスは許可!
----------------------- ---------------- -----------------------
Merry                   Deny ビール      ビール は禁止
======================= ================ =======================

パーミッションを定義する: CakePHP のINI ベースの ACL
====================================================

CakePHP の最初の ACL 実装は、CakePHP のインストールディレクトリに
含まれている INI ファイルに基づくものでした。これは有用でかつ
安定していますが、私たちはデータベース・バックエンドの ACL
ソリューションを推奨しています。その理由のほとんどは、新しい
ACO と ARO をその場で作れるからです。INI ベースの ACL については、
何らかの理由でデータベースを使う予定のない方々については特に、
ごく単純なアプリケーションでの利用を想定していたことをご理解
いただければと思います。

デフォルトでは、CakePHP の ACL はデータベース駆動型です。
INI ベースの ACL を有効にする場合は、app/Config/core.php にある
以下の行を更新することで、CakePHP にどのシステムを使っている
のかを知らせてやる必要があります。

::

    // これらの行を:
    Configure::write('Acl.classname', 'DbAcl');
    Configure::write('Acl.database', 'default');

    // このように変更します:
    Configure::write('Acl.classname', 'IniAcl');
    //Configure::write('Acl.database', 'default');

ARO/ACO のパーミッションは **/app/Config/acl.ini.php** の中で
指定されています。基本的な考え方として、ARO は INI セクション
の中で指定され、groups, allow, deny という３つのプロパティ
を持ちます。

-  groups: この ARO がメンバーである ARO グループの名前
-  allow: この ARO がアクセス権を持つ ACO の名前
-  deny: この ARO がアクセスを禁止されるべき ACO の名前

ACO は INI セクションで指定され、プロパティは allow と deny 
のみです。

例として、私たちが作ってきた 指輪の仲間 ARO 構造を見てみると、
このような INI の書式になります:

::

    ;-------------------------------------
    ; AROs
    ;-------------------------------------
    [aragorn]
    groups = 戦士たち
    allow = 外交交渉権

    [legolas]
    groups = 戦士たち

    [gimli]
    groups = 戦士たち

    [gandalf]
    groups = 魔法使い

    [frodo]
    groups = ホビット族
    allow = 指輪

    [bilbo]
    groups = ホビット族

    [merry]
    groups = ホビット族
    deny = ビール

    [pippin]
    groups = ホビット族

    [gollum]
    groups = 訪問者

    ;-------------------------------------
    ; ARO Groups
    ;-------------------------------------
    [戦士たち]
    allow = 武器, ビール, 塩漬け豚

    [魔法使い]
    allow = 塩漬け豚, 外交交渉権, ビール

    [ホビット族]
    allow = ビール

    [訪問者]
    allow = 塩漬け豚

INI メカニズムを通してパーミッションを定義することができたので、
ACL コンポーネントを使って 
:ref:`パーミッションをチェックする説明 <checking-permissions>`
のところまでスキップできます。もしくは、データベース ACL を使って
同様のパーミッションを定義する方法を引き続き読んでいただいても構いません。

パーミッションを定義する: CakePHP のデータベース ACL
====================================================

ここまでで INI ベースの ACL パーミッションをカバーしました。
さて、（より一般的に使われる）データベース ACL に移りましょう。

はじめに
--------

デフォルトの ACL パーミッション実装はデータベースで動きます。
CakePHP のデータベース ACL は、コアのモデル、および CakePHP の
インストールに含まれるコンソール・アプリケーションの組合せで
構成されています。モデルは CakePHP で使われ、データベースに
問合せてノードをツリーフォーマットで格納または取得します。
コンソール・アプリケーションはデータベースを初期化し、
ACO と ARO ツリーを使えるようにします。

作業を始めるにあたって、まずは ``/app/Config/database.php`` が存在して
かつ適切に設定されていることを確認してください。データベースの
設定についての詳細はセクション 4.1 を参照してください。

これが終わったら、CakePHP のコンソールを使ってあなたの ACL
のデータベーステーブルを作ります:

::

    $ cake schema create DbAcl

このコマンドにより、ACO と ARO の情報をツリー構造で保存するために
必要なテーブルを削除して再作成します。コンソール・アプリケーション
の出力は以下のようになります:

::

    ---------------------------------------------------------------
    Cake Schema Shell
    ---------------------------------------------------------------

    The following tables will be dropped.
    acos
    aros
    aros_acos

    Are you sure you want to drop the tables? (y/n)
    [n] > y
    Dropping tables.
    acos updated.
    aros updated.
    aros_acos updated.

    The following tables will be created.
    acos
    aros
    aros_acos

    Are you sure you want to create the tables? (y/n)
    [y] > y
    Creating tables.
    acos updated.
    aros updated.
    aros_acos updated.
    End create.

.. note::

    これは、以前使われていて廃止された "initdb" というコマンドに
    代わるものです。

``app/Config/Schema/db_acl.sql`` という SQL ファイルを使うことも
できなくはないですが、これは決して楽しいものではありません。

ここまで終わったら、あなたのシステム上に acos, aros, aros\_acos 
（２つのツリーの間でパーミッション情報を生成するための JOIN
テーブル）という３つの新しいテーブルができます。

.. note::

    CakePHP がこれらのテーブルにツリー情報をどう格納しているのかに
    ついて興味があれば、変更されたデータベースツリーを解析してみて
    ください。ACL コンポーネントは CakePHP の
    :doc:`/core-libraries/behaviors/tree` を使ってツリーの継承を
    管理しています。ACL のモデルクラスのファイルは ``lib/Cake/Model/``
    の中にあります。

これですべての準備ができました。それでは ARO と ACO を作って
みましょう。

ARO と ACO の生成
-----------------

新しい ACL オブジェクト（ACO と ARO）を生成するにあたり、ノードに
名前をつけてアクセスするために、主に２つの方法があることを理解
してください。*一つ目の* メソッドは、モデル名と外部キーの値を
指定して、あなたのデータベース内で ACL オブジェクトを直接レコード
にリンクする方法です。*２つ目* は、あなたのデータベースで
オブジェクトからレコードへの直接のリレーションがない場合に
使えます。この場合、オブジェクトを表すテキストの別名をつける
ことができます。

.. note::

    一般的に、グループやハイレベルのオブジェクトを作ろうと思うなら
    別名を使ってください。データベース内の特殊な項目やレコードへの
    アクセスを管理する場合はモデル／外部キーのメソッドを使って
    ください。

CakePHP コアの ACL モデルを使って新しい ACL オブジェクトを作ります。
この時データを保存するために使えるフィールドとしては ``model``,
``foreign_key``, ``alias``, ``parent_id`` があります。

ACL オブジェクトの ``model`` と ``foreign_key`` フィールドを使うと、
オブジェクトをそれに対応するモデルのレコードに（もしそのレコードが
存在すれば）リンクすることができます。たとえば、データベースの中で
多くの ARO にはそれぞれに対応する User レコードがあるとします。
モデルのアソシエーションが正確に設定してあれば、ARO の 
``foreign_key`` を User の ID にセットすることで、ARO と User の
情報を単一の User モデルの find() にリンクすることができます。
反対に、特定のブログのポストやレシピに対する編集操作を管理した
ければ、ACO をその特定のモデルレコードにリンクさせるほうが
いいかもしれません。


``alias`` は単に人間が読むのに便利なラベルであり、モデルの
レコードへの関連がない ACL モデルを指定するのに使えます。
エイリアスは一般にユーザのグループや ACO コレクションに
名前をつけるのに便利です。

ACL オブジェクトの ``parent_id`` を使ってツリー構造に書き込む
ことができます。ツリーの親ノードの ID を指定して新しい子供を
生成します。

新しい ACL オブジェクトを生成する前に、それぞれのクラスをロード
しておく必要があります。もっとも簡単なのは、コントローラーの 
$components 配列で CakePHP の ACL コンポーネントをインクルード
する方法です:

::

    public $components = array('Acl');

ここまでできたら、これらのオブジェクトを生成する例をいくつか
見てみましょう。以下のコードはコントローラーのアクションに
置かれるものです:

.. note::

    ここにある例では ARO の生成に着目していますが、ACO ツリーを
    作るのにも同じ方法が使えます。

私達の 指輪の仲間 の例に戻って、まず ARO グループを作成して
みましょう。それらに紐付いた特定のレコードはないので、
ここではエイリアスを使って ACL オブジェクトを作ります。
ここではコントローラーのアクションを経由して作成していますが、
他のところで作ることも可能です。

私達のアプローチはそんなに新しいものではありません。いつもやって
いるように、以下のような感じでモデルを使ってデータを保存します:

::

    public function any_action() {
        $aro = $this->Acl->Aro;

        // すべてのグループ情報を配列の中で列挙しています
        $groups = array(
            0 => array(
                'alias' => '戦士たち'
            ),
            1 => array(
                'alias' => '魔法使い'
            ),
            2 => array(
                'alias' => 'ホビット族'
            ),
            3 => array(
                'alias' => '訪問者'
            ),
        );

        // 繰り返しながら ARO グループを作っています
        foreach ($groups as $data) {
            // ループの中で保存するときは create() を呼ぶ必要があります...
            $aro->create();

            // データを保存します
            $aro->save($data);
        }

        // その他のアクションのロジックを置きます...
    }

グループができたら、ACL コンソールを使ってツリー構造を
確かめてみます。

::

    $ cake acl view aro

    Aro tree:
    ---------------------------------------------------------------
      [1]戦士たち

      [2]魔法使い

      [3]ホビット族

      [4]訪問者

    ---------------------------------------------------------------

できあがったツリーは現時点ではシンプルなものですが、４つのトップ
レベルノードがあることまでは少なくとも確認できましたね。これらの
グループ配下に特定のユーザ ARO を入れることで、ARO の子ノードを
追加してみましょう。Middle Earth（中つ国）のよい市民たちはみんな
私達の新しいシステムのアカウントを持っていますので、これらの ARO 
をデータベース内で特定のモデルのレコードに紐付けます。


.. note::

    ツリーに子ノードを追加する際は、foreign\_key 値ではなく
    ACL ノードの ID を使うようにしてください。

::

    public function any_action() {
        $aro = new Aro();

        // これが私達の user レコードで、新しい ARO レコードにリンク
        // されようとしています。このデータはモデル由来のもので今後変更
        // されるのですが、ここではデモのために静的な配列を使っています。

        $users = array(
            0 => array(
                'alias' => 'Aragorn',
                'parent_id' => 1,
                'model' => 'User',
                'foreign_key' => 2356,
            ),
            1 => array(
                'alias' => 'Legolas',
                'parent_id' => 1,
                'model' => 'User',
                'foreign_key' => 6342,
            ),
            2 => array(
                'alias' => 'Gimli',
                'parent_id' => 1,
                'model' => 'User',
                'foreign_key' => 1564,
            ),
            3 => array(
                'alias' => 'Gandalf',
                'parent_id' => 2,
                'model' => 'User',
                'foreign_key' => 7419,
            ),
            4 => array(
                'alias' => 'Frodo',
                'parent_id' => 3,
                'model' => 'User',
                'foreign_key' => 7451,
            ),
            5 => array(
                'alias' => 'Bilbo',
                'parent_id' => 3,
                'model' => 'User',
                'foreign_key' => 5126,
            ),
            6 => array(
                'alias' => 'Merry',
                'parent_id' => 3,
                'model' => 'User',
                'foreign_key' => 5144,
            ),
            7 => array(
                'alias' => 'Pippin',
                'parent_id' => 3,
                'model' => 'User',
                'foreign_key' => 1211,
            ),
            8 => array(
                'alias' => 'Gollum',
                'parent_id' => 4,
                'model' => 'User',
                'foreign_key' => 1337,
            ),
        );

        // 繰り返しながら ARO を（子ノードとして）作成します
        foreach ($users as $data) {
            // ループの中で保存する時は create() を呼ぶ必要があります...
            $aro->create();

            // データを保存します
            $aro->save($data);
        }

        // ここにその他のアクションのロジックを置きます...
    }

.. note::

    通常はエイリアスやモデル／外部キーのいずれとも指定することは
    ありませんが、ここでは説明のため、ツリー構造がより読みやすく
    なるように両方とも指定しています。

これでコンソール・アプリケーションコマンドの出力がちょっとおもしろい
ものになります。早速見てみましょう:

::

    $ cake acl view aro

    Aro tree:
    ---------------------------------------------------------------
      [1]戦士たち

        [5]Aragorn

        [6]Legolas

        [7]Gimli

      [2]魔法使い

        [8]Gandalf

      [3]ホビット族

        [9]Frodo

        [10]Bilbo

        [11]Merry

        [12]Pippin

      [4]訪問者

        [13]Gollum

    ---------------------------------------------------------------

これで ARO のツリーを正しく設定することができましたので、次に
ACO のツリーを構成するにはどうしたらよいかを考えてみましょう。
ACO についてより抽象的に表現することもできるのですが、よく
使われるのは CakePHP のコントローラー／アクション設定の後に
ACO ツリーのモデルを作るやり方です。私たちの「指輪の仲間」の
シナリオでは、５つの主なオブジェクトを扱っています。CakePHP
アプリケーションの中で自然な形でこれらの設定を行うには、
グループのモデルとそれらを操作するための完璧なコントローラー
が必要になります。これらのコントローラー自身を超えて、これら
内部の特定のアクションにアクセスしたいものです。

CakePHP のアプリケーションの設定を真似た ACO ツリーをセットアップ
してみましょう。５つの ACO がありますが、以下のようになる
ような ACO ツリーを作ってみます:

-  武器
-  指輪
-  豚の厚切り肉
-  外交努力
-  ビール

CakePHP の ACL セットアップにおいて、幸いなことにそれぞれの ACO は
自動的に CRUD (create,read, update, delete) アクションに紐付いた
４つのプロパティを持ちます。これら５つの主となる ACO それぞれの
配下に子ノードを作ることもできますが、CakePHP 組み込みのアクション
管理を使うことで、与えられたオブジェクトについての基本的な CRUD 操作
をカバーできます。このことを覚えておけば、あなたの ACO ツリーはより
小さくなり、またメンテナンスも容易になるでしょう。これらがどう使われる
のかは、後述のパーミッションの割り当てのところで見ていきます。

これで ARO の追加については習得できましたので、同じやり方を ACO
ツリーについても適用します。コアの Aco モデルを使ってこれら上位
レベルのグループを作成してください。

パーミッションの割り当て
------------------------

ACO と ARO の作成が終わったら、やっとそれら２つのグループ間で
パーミッションを割り当てることができるようになります。これは
CakePHP のコア Acl コンポーネントによって行われます。
私たちの例に沿って続けてみましょう。

ここはコントローラーのアクションの中で作業します。なぜなら
パーミッションは Acl コンポーネントによって管理されるからです。

::

    class SomethingsController extends AppController {
        // これを AppController に置きたいと思うかもしれませんが、
        // これでもちゃんと動作します。

        public $components = array('Acl');

    }

次に、コントローラーの中のアクションで、AclComponent を使って
いくつかの基本的なパーミッションを設定してみましょう。

::

    public function index() {
        // 戦士たちに武器への完全なアクセス権を与えます。
        // これらの例ではいずれもエイリアス書式を使っています。
        $this->Acl->allow('戦士たち', '武器');

        // しかしながら、王は全員に自由なアクセス権をもたせるのを
        // よしとしません。
        $this->Acl->deny('戦士たち/Legolas', '武器', 'delete');
        $this->Acl->deny('戦士たち/Gimli',   '武器', 'delete');

        die(print_r('done', 1));
    }

最初の呼び出しで、AclComponent は '戦士たち' ARO グループ配下の
すべてのユーザに、'武器' ACO グループ配下のすべてに対するフル
アクセスを与えます。ここでは単にそれらのエイリアスによって ACO と
ARO を特定しています。

３つ目のパラメーがありますね。これはすべての CakePHP の ACO に
組み込まれている便利なアクションです。このパラメータのデフォルト
のオプションは ``create``, ``read``, ``update``, ``delete`` ですが、
``aros_acos`` データベーステーブル（実際は、たとえば ``_admin`` 
のように接頭辞がつきます）にカラムを追加して、それをデフォルト値と
合わせて指定することも可能です。

２つ目の呼び出しの組み合わせでは、より粒度の細かいパーミッション
の決定を行おうとしています。私たちは Aragorn にはフルアクセス権限
をそのまま持っていてほしいと思う反面、そのグループ内のそれ以外の
戦士たちには武器レコードの削除を行わせたくありません。ここでは
前述のエイリアス書式を使って ARO の指定を行っていますが、
モデル／外部キー書式を使いたい場合もあるかもしれません。
上記の指定は以下と同じ意味になります:

::

    // 6342 = Legolas
    // 1564 = Gimli

    $this->Acl->deny(
      array('model' => 'User', 'foreign_key' => 6342),
      '武器',
      'delete'
    );
    $this->Acl->deny(
      array('model' => 'User', 'foreign_key' => 1564),
      '武器',
      'delete'
    );

.. note::

    エイリアス書式を使ってノードを指定する場合、スラッシュ区切り
    文字列 ('/users/employees/developers') を使います。
    一方、モデル／外部キー書式を使ったノードの指定では、
    ``array('model' => 'User', 'foreign_key' => 8282)``
    のように２つのパラメータを使います。

次のセクションでは、今までに設定してきたパーミッションを
AclComponent を使ってチェックすることにより、設定内容の
バリデーションについて説明します。

.. _checking-permissions:

パーミッションをチェックする: ACL コンポーネント
------------------------------------------------

AclComponent を使ってドワーフ(Dwarf)やエルフ(Elf)が武器庫から
何も移動できないことを確認してみましょう。この時点で、私たちは
AclComponent を使って自分たちで作った ACO や ARO の間でチェック
ができるようになっているはずです。パーミッションをチェックする
ための基本的な文法は以下のようになります:

::

    $this->Acl->check($aro, $aco, $action = '*');

これをコントローラーのアクションの中で試してみましょう:

::

    public function index() {
        // これらはどれも true を返します:
        $this->Acl->check('戦士たち/Aragorn', '武器');
        $this->Acl->check('戦士たち/Aragorn', '武器', 'create');
        $this->Acl->check('戦士たち/Aragorn', '武器', 'read');
        $this->Acl->check('戦士たち/Aragorn', '武器', 'update');
        $this->Acl->check('戦士たち/Aragorn', '武器', 'delete');

        // 私たちの ARO についてモデル/ID の書式を使えることも
        // 覚えておきましょう。
        $this->Acl->check(array('User' => array('id' => 2356)), '武器');

        // これらも true を返します:
        $result = $this->Acl->check('戦士たち/Legolas', '武器', 'create');
        $result = $this->Acl->check('戦士たち/Gimli', '武器', 'read');

        // しかしこれらは false を返します:
        $result = $this->Acl->check('戦士たち/Legolas', '武器', 'delete');
        $result = $this->Acl->check('戦士たち/Gimli', '武器', 'delete');
    }

ここでの例はあくまでもデモンストレーションのためのものですが、
こんな感じでチェックを行うことで、アクションが許可されるかどうかを
決めたり、エラーメッセージを表示したり、またユーザをログインに
リダイレクトしたりということが可能です。

.. meta::
    :title lang=en: Access Control Lists
    :keywords lang=en: fantasy novel,access control list,request objects,online diary,request object,acls,adventurers,gandalf,lingo,web service,computer system,grandma,lord of the rings,entities,assets,logic,cakephp,stuff,control objects,control object
