アクセス制御リスト
##################

CakePHP のアクセス制御リスト(\ *Access Control List*,
*ACL*)は、頻繁に話題になる機能のひとつです。これは、非常に多く使われる機能でありながら、とても混乱しやすいものであることが原因です。ACL
の概要を理解する近道を探しているならば、この章を読むことからはじめてください。

難しい所が出てきても、勇気を出して粘り強く取り組んでください。いったんコツがつかめたら、この機能はアプリケーションの開発において極めて強力なツールになります。

ACL の動作を理解する
====================

強力なアプリケーションにはアクセス制御機能が必要です。
アクセス制御リストは、優れた保守性と管理性を保ちつつ、アプリケーションのパーミッションをきめ細かく設定する機能を提供します。

アクセス制御リスト(\ *Access Control List* または
*ACL*)は、主に二つの物を扱います。
ひとつめは、何かを取り扱う「主体」、そしてもうひとつは、その主体に取り扱われる「物」です。
ACL の専門用語では、物を扱う「主体」(たとえばユーザ)は、
「アクセスリクエストオブジェクト(ARO)」と呼び、
その主体(ARO)が扱う「物」(たとえばデータ)は、
「アクセスコントロールオブジェクト(ACO)」と呼びます。
これらが「オブジェクト」と呼ばれているのは、ARO
が人であるとは限らないからです。
例えば、アプリケーションの別の部分でロジックを開始するために、ある特定の
Cake
のコントローラがアクセスを持っているとします。これを制限したい時があるかもしれません。
ACO には、コントローラアクション、WEB
サービス、おばあちゃんのオンライン日記への回線など、アクセスをコントロールできる物なら何でもあてはまります。

復習してみましょう。

-  ACO - アクセスコントロールオブジェクト(\ *Access Control Object*) -
   ある主体が取り扱う「物」
-  ARO - アクセスリクエストオブジェクト(\ *Access Request Object*) -
   ある物を取り扱う「主体」

つまり ACL とは、 ARO がいつ ACO
にアクセスできるかを決定するために用いるものなのです。

分かりやすくするために、少し具体的な例を使ってみましょう。
ファンタジー冒険小説「指輪物語」に登場するようなグループを使うコンピュータのシステムを想像してください。
グループのリーダーであるガンダルフは、各メンバーのプライバシーとセキュリティを十分に管理したいと考えています。
ガンダルフがまずすべきは、次のものが含まれた ARO
のリストを作成することです。

-  ガンダルフ
-  アラゴルン
-  ビルボ
-  フロド
-  ゴクリ
-  レゴラス
-  ギムリ
-  ピピン
-  メリー

ACL は、ユーザを認証するシステムでは\ *ない*\ ことに注意してください。
ACL はユーザが認証された\ *後*\ に使うものです。
「それが誰なのか」を判断するのが「認証」で、「その人は何ができるのか」を判断するのが「ACL」です。この二つは協調して使われますが、異なる仕組みであることは意識しておきましょう。

ガンダルフが次に必要とするものは、システムが扱う物である ACO
の初期リストです。このリストは次のようになります。

-  武器
-  一つの指輪
-  塩漬け豚
-  外交術
-  ビール

伝統的な手法だと、これらはユーザとパーミッションをオブジェクトに関連付ける基本的なセットをマトリクス状に並べたもので管理されます。
表組みであらわすと、次のようになります。

武器

一つの指輪

塩漬け豚

外交術

ビール

ガンダルフ

許可

許可

許可

アラゴルン

許可

許可

許可

許可

ビルボ

許可

フロド

許可

許可

ゴクリ

許可

レゴラス

許可

許可

許可

許可

ギムリ

許可

許可

ピピン

許可

許可

メリー

許可

一見したところ、こういう形のシステムでうまくいくように思えます。
フロドだけが一つの指輪にアクセスできるよう、セキュリティの保護がなされています。
また、ホビットたちは塩漬け豚や武器に触れられず、間違いが起こらないようにもなっています。
これで十分に整理されていて、読みやすいように思えますね。しかし本当にこれで十分なのでしょうか？

このような小さいシステムであれば、マトリクス状の設定でうまくいくでしょう。
しかし、システムが大きくなってきたり、リソース(ACO)やユーザ(ARO)がかなりの数になる場合、
テーブルは素早く扱えなくなり、取り回しも悪くなります。
指輪戦争における数百という陣営のアクセスを管理する場合、そしてそれをさらに部隊ごとに管理しようとする場合を想像してください。
マトリクスのもう一つの欠点は、ユーザのかたまりを論理的にグループ分けしたり、論理的なグループ分けに基づいてあるユーザグループのパーミッションをまとめて変更したりできないことです。
例えば、戦闘終了後は自動的に、ホビットたちがビールや塩漬け豚へのアクセスを許可されるようにできるとよいかもしれません。
これを個別のユーザごとに行うのは、退屈でエラーの起こりやすい作業になります。
しかし、すべての「ホビット」に許可をまとめて与える、というのは簡単です。

ACL は通常、木構造で実装されます。 たいていの場合、 ARO のツリーと ACO
のツリーが存在します。
各オブジェクトを木構造で整理すると、きめ細かいパーミッションの設定を行いつつ、全体像もしっかりと把握しながらメンテナンスできます。
賢明なリーダーであるガンダルフは新システムで ACL を採用し、
それぞれのオブジェクトを次のように整理し始めました

-  旅の仲間

   -  戦士

      -  アラゴルン
      -  レゴラス
      -  ギムリ

   -  魔法使い

      -  ガンダルフ

   -  ホビット

      -  フロド
      -  ビルボ
      -  メリー
      -  ピピン

   -  来訪者

      -  ゴクリ

ARO
に木構造を用いると、ガンダルフはグループの全てのユーザに対し、一度にパーミッションを設定することができます。
ここでガンダルフは、ARO
ツリーを使ってグループに対するパーミッションをいくつか付け加えました。

-  旅の仲間
   (**Deny**: all)

   -  戦士
      (**Allow**: 武器, ビール, エルフの食べ物, 塩漬け豚)

      -  アラゴルン
      -  レゴラス
      -  ギムリ

   -  魔法使い
      (**Allow**: 塩漬け豚, 外交術, ビール)

      -  ガンダルフ

   -  ホビット
      (**Allow**: ビール)

      -  フロド
      -  ビルボ
      -  メリー
      -  ピピン

   -  来訪者
      (**Allow**: 塩漬け豚)

      -  ゴクリ

ACL
を使ってピピンがビールにアクセスできるかをどうかを確認には、まずツリーの中のどこにいるかを探します。この場合、「旅の仲間->ホビット->ピピン」というパスになります。
次に、各ポイントのパーミッションを確認し、ピピンとビールを関連づけている一番近いパーミッションを使用します。

+--------------+----------------------+-------------------------------+
| ARO ノード   | パーミッション情報   | 結果                          |
+==============+======================+===============================+
| 旅の仲間     | Deny all             | ビールへアクセスできない。    |
+--------------+----------------------+-------------------------------+
| ホビット     | Allow 'ビール'       | ビールへアクセスできる！      |
+--------------+----------------------+-------------------------------+
| ピピン       | --                   | まだビールへアクセスできる！  |
+--------------+----------------------+-------------------------------+

ACL
ツリーの「ピピン」ノードで、ACO「ビール」へのアクセスが明確に拒否されない限り、
最終的にはその ACO に対するアクセスは許可されます。

木構造による ACL では ARO
グループ全体に対する設定を保ったまま、さらに細かくコントロールの調節を行うことが出来ます。

-  旅の仲間
   (**Deny**: all)

   -  戦士
      (**Allow**: 武器, ビール, エルフの食べ物, 塩漬け豚)

      -  アラゴルン
         (Allow: 外交術)
      -  レゴラス
      -  ギムリ

   -  魔法使い
      (**Allow**: 塩漬け豚, 外交術, ビール)

      -  ガンダルフ

   -  ホビット
      (**Allow**: ビール)

      -  フロド
         (Allow: 一つの指輪)
      -  ビルボ
      -  メリー
         (Deny: ビール)
      -  ピピン
         (Allow: 外交術)

   -  来訪者
      (**Allow**: 塩漬け豚)

      -  ゴクリ

この方法では、パーミッションの一括変更と細かな調節を両立できます。
上述の例では、メリーを除いた全てのホビットがビールにアクセスできるようになっています。
メリーがビールにアクセスで出来るかどうか確認するには、ツリーの中で「旅の仲間->ホビット->メリー」というパスを見つけ、ビールに関連したパーミッションを下へと追って行きます。

+--------------+----------------------+------------------------------+
| ARO ノード   | パーミッション情報   | 結果                         |
+==============+======================+==============================+
| 旅の仲間     | Deny all             | ビールへアクセスできない。   |
+--------------+----------------------+------------------------------+
| ホビット     | Allow 'ビール'       | ビールへアクセスできる！     |
+--------------+----------------------+------------------------------+
| メリー       | Deny 'ビール'        | ビールへアクセスできない。   |
+--------------+----------------------+------------------------------+

パーミッションの定義： Cake の INI-ベース ACL
=============================================

初期における CakePHP への ACL の実装は、 CakePHP
のインストール時に保存される INI ファイルに基づいていました。
これも便利で安定してはいますが、データベースによる ACL
ソリューションの利用をお勧めします。 そのほうが ACO と ARO
を素早く作成できるからです。 INI ファイルに基づく ACL
は、シンプルなアプリケーションや、何らかの理由でデータベースを使用できない場合などに利用するとよいでしょう。

デフォルトでは、 CakePHP の ACL はデータベースを利用します。 INI
ベースの ACL を有効にするには、 app/config/core.php
の次の行を上書きしてください。

::

    // これらの行を変更する
    Configure::write('Acl.classname', 'DbAcl');
    Configure::write('Acl.database', 'default');

    // 変更した内容は次のとおり
    Configure::write('Acl.classname', 'IniAcl');
    //Configure::write('Acl.database', 'default');

ARO/ACO パーミッションは、 **/app/config/acl.ini.php**
で定義されています。 ARO は INI セクションで定義されており、 INI
セクションは「groups」「allow」「deny」という三つのプロパティを持つというのが基本的な考え方です。

-  groups: その ARO が所属するグループ名。
-  allow: その ARO のアクセスを許可する ACO の名前。
-  deny: その ARO のアクセスを拒否する ACO の名前。

ACO は allow か deny プロパティのみを含む INI
セクションで定義されています。

先の例における「旅の仲間」の ARO の構造を INI
シンタックスで作成したものを見てみましょう。
(訳注：理解しやすいよう例には日本語を含めていますが、それでは実際には動作しません。)

::

    ;-------------------------------------
    ; ARO
    ;-------------------------------------
    [アラゴルン]
    groups = 戦士
    allow = 外交術

    [レゴラス]
    groups = 戦士

    [ギムリ]
    groups = 戦士

    [ガンダルフ]
    groups = 魔法使い

    [フロド]
    groups = ホビット
    allow = 一つの指輪

    [ビルボ]
    groups = ホビット

    [メリー]
    groups = ホビット
    deny = ビール

    [ピピン]
    groups = ホビット

    [ゴクリ]
    groups = 来訪者

    ;-------------------------------------
    ; ARO のグループ
    ;-------------------------------------
    [戦士]
    allow = 武器, ビール, 塩漬け豚

    [魔法使い]
    allow = 塩漬け豚, 外交術, ビール

    [ホビット]
    allow = ビール

    [来訪者]
    allow = 塩漬け豚

これでパーミッションが定義されました。もう ACL
コンポーネントを使いたいなら\ `パーミッションのチェックに関する章 </ja/view/471/checking-permissions-the-acl-c>`_\ までスキップしてください。

パーミッションの定義： Cake のデータベース ACL
==============================================

INI ベースの ACL パーミッションについては説明しました。INI
ベースのものよりよく使われるデータベースを用いた ACL
について見ていきましょう。

はじめに
--------

デフォルトの ACL パーミッションの実装はデータベースを使用します。
CakePHP のデータベースを用いる ACL
は、一連のコアモデルとコマンドラインのスクリプトで構成されています。
これらのファイルは CakePHP をインストールすると作成されます。 モデルは、
CakePHP がデータベースとやりとりをし、ACL
ツリーノードの保存と読み出しを行うために使用します。
コマンドラインのスクリプトは、データベースの初期化と、ACO および ARO
ツリーのやりとりのために使います。

はじめる前に、 ``/app/config/database.php``
が存在し、正しく設定されていることを確認してください。
この設定についてのより詳しい情報は、 3.4.1 章を参照してください。

設定が完了したら、 CakePHP
のコマンドラインスクリプトを使ってデータベースに ACL
のテーブルを作成しましょう。

::

    $ cake schema run create DbAcl

このコマンドは、 ACO と ARO
の情報を木構造で保存するためのテーブルをドロップして再生成します。
コマンドを実行したとき、スクリプトの出力は次のようになります。

::

    ---------------------------------------------------------------
    Cake Schema Shell
    ---------------------------------------------------------------

    The following tables will be dropped.
    acos
    aros
    aros_acos

    Are you sure you want to drop the tables? (y/n) 
    [n] > y
    Dropping tables.
    acos updated.
    aros updated.
    aros_acos updated.

    The following tables will be created.
    acos
    aros
    aros_acos

    Are you sure you want to create the tables? (y/n) 
    [y] > y
    Creating tables.
    acos updated.
    aros updated.
    aros_acos updated.
    End create.

これは、古いバージョンで使われていて評判の良くなかった「initdb」を代替するコマンドです。

面白味に欠ける方法ではありますが、\ ``app/config/sql/db_acl.sql`` にある
SQL ファイルを実行しても同じ結果が得られます。

実行が完了したら、システム中に三つの新しいデータベーステーブルが作られます。
それぞれ、「acos」「aros」そしてこのテーブルを結合しパーミッション情報を作成する「aros\_acos」となります。

CakePHP
がこれらのテーブルに木構造の情報をどのように保存するかについて興味があるなら、それをデータベースでどのように表現し変更するのかを調べてみてください。
ACL コンポーネントは木構造の継承を管理するために CakePHP
の\ `ツリービヘイビア </ja/view/91/ツリー>`_\ を利用します。 また、 ACL
に関するすべてのモデルクラスは、
`db\_acl.php <https://api.cakephp.org/1.2/cake_2libs_2model_2db__acl_8php-source.html>`_
に集められています。

これで、ARO と ACO ツリーが作成できるようになったはずです。

アクセスリクエストオブジェクト (ARO) とアクセスコントロールオブジェクト (ACO) の作成
------------------------------------------------------------------------------------

新しい ACL オブジェクト(つまり ACO と ARO)
を作成する時に、ノードに名前を付けアクセスするには、主に二つの方法があります。
*一つ目*\ は、モデル名と外部キーの値を特定し、ACL
オブジェクトをデータベース中のレコードに直接リンクする方法です。
*二つ目*\ はオブジェクトに対して別名を文字列で提供する方法で、これは ACL
オブジェクトが直接関連付くレコードが存在しない場合に利用します。

通常、別名を使うのは、グループや高いレベルのオブジェクトを作成する場合です。
もしデータベース中の特定のアイテムやレコードへのアクセスを管理したいなら、モデル名と外部キーを使う方法を採用してください。

新しい ACL オブジェクトを作成するには、CakePHP コアの ACL
モデルを使用します。
その際、データを保存する時に使うフィールドとして、「\ ``model``\ (モデル名)」「``foreign_key``\ (外部キー)」「``alias``\ (別名)」そして「``parent_id``\ (親
ID)」というものがあります。

ACL
オブジェクトの「\ ``model``\ (モデル名)」と「``foreign_key``\ (外部キー)」フィールドは、オブジェクトと、あるモデルの一つのレコードをリンクするために使います。
例えば、 ARO がデータベース中の User レコードに対応している場合です。
ARO の ``foreign_key``\ (外部キー) に User モデルの id を設定すると、
ARO と User の情報がリンクされます。 User の情報には、単独の
Model::find()
の実行結果が(もしアソシエーションが正しく定義されていれば、それも)含まれます。
逆に、ある特定のブログの投稿やレシピの表などを編集する作業を管理したい場合は、これらのモデルのレコードを
ACO にリンクさせます。

ACL の ``alias``\ (別名) は、モデルのレコードに直接結びつかない ACL
オブジェクトに、 読んで理解できるラベルを付けるために使用します。
別名は、ユーザのグループや ACO の集合に名前を付ける時に便利です。

ACL オブジェクトの ``parent_id``\ (親 ID)
は、木構造を構築するために使います。
新しい子ノードを作成するには、ツリー中の親ノードの ID を指定します。

新しい ACL
オブジェクトを作成する前に、まずそれぞれのクラスを読み込まねばなりません。
もっとも簡単な方法は、コントローラ中の $components 配列で ACL
コンポーネントを読み込むよう設定することです。

::

    var $components = array('Acl');

これを行ったら、オブジェクトを作成する例がどのようになるのかを見てみましょう。
次のコードをコントローラアクションのどこかに置いてください。

この例では ARO の作成にフォーカスしていますが、 ACO
のツリーも同様に作成できます。

「旅の仲間」の設定で、最初の ARO グループを作成してみましょう。
グループは特定のレコードに結びつかないので、別名を使って ACL
オブジェクトを作成します。
ここではあるコントローラアクション中で実行しますが、どこでも好きなところで行えます。
またこの例においては、 ARO と ACO
を作成する方法を理解しやすくするため、やや恣意的なアプローチを採用しています。

特に目新しい点は何もありません。普通にモデルを使ってデータを保存しています。

::

    function anyAction()
    {
        $aro = new Aro();
        
        // 配列に全てのグループの情報を定義する
        $groups = array(
            0 => array(
                'alias' => '戦士'
            ),
            1 => array(
                'alias' => '魔法使い'
            ),
            2 => array(
                'alias' => 'ホビット'
            ),
            3 => array(
                'alias' => '来訪者'
            ),
        );
        
        // 配列をループさせ、 ARO グループを作成する
        foreach($groups as $data)
        {
            // ループ中でデータの保存を行う場合、 create() を忘れずに実行してください
            $aro->create();
            
            // データを保存する
            $aro->save($data);
        }

        // 別のアクションのロジックが続く
    }

これを実行したら、コマンドラインの ACL
アプリケーションを使って木構造を確認してみましょう。

::

    $ cake acl view aro

    Aro tree:
    ---------------------------------------------------------------
      [1]戦士

      [2]魔法使い

      [3]ホビット

      [4]来訪者

    ---------------------------------------------------------------

この段階では大したツリーではありませんが、少なくとも四つのトップレベルノードがあることが確認できます。
特定のユーザに対応した ARO を先ほど作成したグループに追加し、 ARO
ノードに子を追加していきましょう。
中つ国(訳注：指輪物語の舞台)の全ての住人はこのシステムでアカウントを持っているため、
データベース中のあるモデルの特定のレコードと ARO
レコードを結びつけることができます。

ツリーに子ノードを加える場合、外部キーの値ではなく ACL のノード ID
を使うようにしてください。

::

    function anyAction()
    {
        $aro = new Aro();
        
        // 新しい ARO レコードにリンクするユーザのレコードを取得します。
        // 通常、このデータには、モデルから取得したものやそれを加工したものを使います。
        // しかしこの例はデモンストレーションなので、静的な配列で定義してしまいます。
        
        $users = array(
            0 => array(
                'alias' => 'アラゴルン',
                'parent_id' => 1,
                'model' => 'User',
                'foreign_key' => 2356,
            ),
            1 => array(
                'alias' => 'レゴラス',
                'parent_id' => 1,
                'model' => 'User',
                'foreign_key' => 6342,
            ),
            2 => array(
                'alias' => 'ギムリ',
                'parent_id' => 1,
                'model' => 'User',
                'foreign_key' => 1564,
            ),
            3 => array(
                'alias' => 'ガンダルフ',
                'parent_id' => 2,
                'model' => 'User',
                'foreign_key' => 7419,
            ),
            4 => array(
                'alias' => 'フロド',
                'parent_id' => 3,
                'model' => 'User',
                'foreign_key' => 7451,
            ),
            5 => array(
                'alias' => 'ビルボ',
                'parent_id' => 3,
                'model' => 'User',
                'foreign_key' => 5126,
            ),
            6 => array(
                'alias' => 'メリー',
                'parent_id' => 3,
                'model' => 'User',
                'foreign_key' => 5144,
            ),
            7 => array(
                'alias' => 'ピピン',
                'parent_id' => 3,
                'model' => 'User',
                'foreign_key' => 1211,
            ),
            8 => array(
                'alias' => 'ゴクリ',
                'parent_id' => 4,
                'model' => 'User',
                'foreign_key' => 1337,
            ),
        );
        
        // 定義した配列をループでまわして ARO を子として作成する
        foreach($users as $data)
        {
            // ループ中でデータの保存を行う場合、 create() を忘れずに実行してください
            $aro->create();

            // データを保存する
            $aro->save($data);
        }
        
        // 別のアクションのロジックが続く
    }

普通、モデル名(\ *model*)と外部キー(\ *foreign\_key*)を使って ARO
と結びつける場合、 別名(\ *alias*)は使用しません。
この例ではデモンストレーション用にツリーを読みやすくするため、あえて別名を定義しています。

コマンドラインの ACL
アプリケーションの出力が少し面白くなっています。見てみましょう。

::

    $ cake acl view aro

    Aro tree:
    ---------------------------------------------------------------
      [1]戦士

        [5]アラゴルン

        [6]レゴラス

        [7]ギムリ

      [2]魔法使い

        [8]ガンダルフ

      [3]ホビット

        [9]フロド

        [10]ビルボ

        [11]メリー

        [12]ピピン

      [4]来訪者

        [13]ゴクリ

    ---------------------------------------------------------------

ARO ツリーをきちんと設定できましたので、次に ACO
ツリーを構築するアプローチにどのようなものがあるのかを見ていきましょう。
ACO はより多くの抽象的な表現を構築することができるので、 ACO
ツリーをモデルするのは CakePHP の Controller/Action
セットアップの後に行うことが実用的でしょう。
この「旅の仲間」の筋書においては、主に五つのオブジェクトを使います。
CakePHP
のアプリケーション中では、これらをモデルのグループとして、そして最終的にはそれらを扱うコントローラとしてセットアップするのが自然です。
さらに進んで、アクセスの特定のアクションを制御することもできます。

この考えに基づき、CakePHP のアプリケーションのセットアップに似せた ACO
ツリーをセットアップしましょう。 五つの ACO を持っていますので、ACO
ツリーは次のようになります。

-  武器
-  指輪
-  豚の切り身
-  外交努力
-  ビール

CakePHP の ACL セットアップにおいてすばらしいことは、それぞれの ACO
が自動的に CRUD(create, read, update, delete)
アクションに関連したプロパティを持つことです。 これら五つの主な ACO
のそれぞれの下に、子ノードを作成すると、 CakePHP
の組み込みアクション管理機能の利用は、与えられたオブジェクトに対する基本的な
CRUD の操作をカバーします。 これを意識しておくと、 ACO
ツリーが簡潔で保守しやすいものになります。
これらをどのように使うかは、パーミッションを割り当てる方法を説明する時に見ていきます。

これで、 ACO ツリーを作成するテクニックと同様に、 ARO
を追加することも学びました。 コアの Aco
モデルを使って、それらの上位のグループを作成してください。

パーミッションの割り当て
------------------------

ACO と ARO
を作成したら、いよいよその二つのグループ間にパーミッションを割り当てられます。これは
CakePHP コアの Acl コンポーネントで行います。例に沿って続けましょう。

これはコントローラのアクションの中で実行します。なぜなら、パーミッションの管理は
Acl コンポーネントが行うからです。

::

    class SomethingsController extends AppController
    {
        // ここに指定する代わりに AppController 中で指定したいと思うかもしれませんが、
        // ここでも問題なく動きます。

        var $components = array('Acl');

    }

コントローラのアクション中で AclComponent
を使い、基本的なパーミッションをセットアップしてみましょう。

::

    function index()
    {
        // 戦士に武器への完全なアクセスを許可する。
        // これらの例では全て、別名(alias)を使って設定してみます。
        $this->Acl->allow('戦士', '武器');
        
        // 王は全ての者が無制限のアクセスを持つことを
        // お望みにならない
        $this->Acl->deny('戦士/レゴラス', '武器', 'delete');
        $this->Acl->deny('戦士/ギムリ',   '武器', 'delete');
        
        die(print_r('done', 1));
    }

まず最初の呼び出しで、 AclComponent に「戦士」という ARO
のグループに対して、「武器」という ACO
のグループへ完全なアクセスを与えています。 ここでは、 ACO と ARO
のアドレス指定に別名を使っています。

三つ目のパラメータはどうやって使うのでしょうか。 これが、 CakePHP
の全ての ACO
に組み込まれている便利なアクションです。このオプションのデフォルトの値は「\ ``create``\ (生成)」「``read``\ (読み込み)」「``update``\ (更新)」そして「``delete``\ 」です。が、\ ``aros_acos``
データベーステーブル(あるいはこれを前置詞として「\_」でつなげたテーブル。例えば
``_admin``)にカラムを追加し、デフォルトのものと一緒に使うことができます。

二つ目の呼び出しセットでは、さらにきめ細かなパーミッションの設定を行おうとしています。アラゴルンにはフルアクセスの特権を与えたまま、同じグループの他の戦士は武器のレコードを削除(\ *delete*)できないようにしています。上述の例では、ARO
のアドレス指定に別名を用いたシンタックスを使っていますが、モデル名と外部キーを用いるシンタックスを使うこともできます。これに相当するものは、次のようになります。:

::

    // 6342 = レゴラス
    // 1564 = ギムリ

    $this->Acl->deny(array('model' => 'User', 'foreign_key' => 6342), '武器', 'delete');
    $this->Acl->deny(array('model' => 'User', 'foreign_key' => 1564), '武器', 'delete');

別名によるノードのアドレス指定のシンタックスは、スラッシュをデリミタにした文字列(例えば
「/users/employees/developers」)を使います。モデル名と外部キーによるノードのアドレス指定を行うには、
``array('model' => 'User', 'foreign_key' => 8282)``
というような二つのパラメータを持つ配列を使います。

次の章では、AclComponent
を使ってセットアップしたパーミッションをチェックする機能を有効にする方法について説明します。

パーミッションのチェック： ACL コンポーネント
---------------------------------------------

AclComponent
を使って、ドワーフとエルフが武器庫から何も削除できないようにしましょう(訳注：アラゴルンは人間、ギムリはドワーフ、レゴラスはエルフです)。
それにあたり、 AclComponent を使って、作成した ACO と ARO
の間の関係をチェックすることが出来ます。
パーミッションのチェックを行う基本的なシンタックスはこのようになります。

::

    $this->Acl->check( $aro, $aco, $action = '*');

コントローラアクションの中で実行してみましょう。

::

    function index()
    {
        // これらは全て true を返します。
        $this->Acl->check('戦士/アラゴルン', '武器');
        $this->Acl->check('戦士/アラゴルン', '武器', 'create');
        $this->Acl->check('戦士/アラゴルン', '武器', 'read');
        $this->Acl->check('戦士/アラゴルン', '武器', 'update');
        $this->Acl->check('戦士/アラゴルン', '武器', 'delete');
        
        // ユーザの ARO にモデル名と外部キーを用いたシンタックスを
        // 使用できることを忘れないでください。
        $this->Acl->check(array('model' => 'User', 'foreign_key' => 2356), '武器');
        
        // これらも全て true を返します。
        $result = $this->Acl->check('戦士/レゴラス', '武器', 'create');
        $result = $this->Acl->check('戦士/ギムリ', '武器', 'read');
        
        // 一方、これらは false を返します。
        $result = $this->Acl->check('戦士/レゴラス', '武器');
        $result = $this->Acl->check('戦士/ギムリ', '武器', 'delete');
    }

この使い方はデモンストレーション用のものですが、何が出来るかはわかるでしょう。
実際にはパーミッションを判定したあと、何か処理を実行することを許可するのか、エラーメッセージを表示するのか、ログインページにリダイレクトするのかといった振る舞いを決定します。
